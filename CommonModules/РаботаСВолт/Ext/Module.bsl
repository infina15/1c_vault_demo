
Функция ПолучитьСекрет(Путь, ИмяСекрета) Экспорт
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	т.АдресСервера КАК АдресСервера,
	|	т.ИмяРоли КАК ИмяРоли,
	|	т.ТокенДоступа КАК ТокенДоступа
	|ИЗ
	|	Справочник.Волт_Настройка КАК т
	|ГДЕ
	|	т.Ссылка = ЗНАЧЕНИЕ(Справочник.Волт_Настройка.Волт)";
	Выборка = Запрос.Выполнить().Выбрать();
	Если НЕ Выборка.Следующий() Тогда
		ВызватьИсключение "Не найдена настройка Vault";
	КонецЕсли;
	Соединение = Новый HTTPСоединение(Выборка.АдресСервера,,,,,10, Новый ЗащищенноеСоединениеOpenSSL);
	АдресРесурса = СтрШаблон("/v1/auth/%1/login", Выборка.ИмяРоли);
	Запрос = Новый HTTPЗапрос(АдресРесурса);
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Новый Структура("jwt, role", Выборка.ТокенДоступа, Выборка.ИмяРоли));
	Джейсон_Токен = Запись.Закрыть();
	Запрос.УстановитьТелоИзСтроки(Джейсон_Токен);
	Ответ = Соединение.ВызватьHTTPМетод("POST", Запрос);
	
	Если (Ответ.КодСостояния < 200) ИЛИ (Ответ.КодСостояния >= 300) Тогда
		ВызватьИсключение СтрШаблон("Ошибка авторизации в Vault : %1
									|%2'"
									,Строка(Ответ.КодСостояния)
									,Ответ.ПолучитьТелоКакСтроку()); 
	КонецЕсли;
	
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(Ответ.ПолучитьТелоКакСтроку());
	Ответ_Структура = ПрочитатьJSON(Чтение);
	Чтение.Закрыть();
	
	ТокенСессии = Ответ_Структура.auth.client_token;
	
	ЗапросСекрета = Новый HTTPЗапрос(Путь);
	ЗапросСекрета.Заголовки.Вставить("X-Vault-Token", ТокенСессии);
	
	Ответ = Соединение.ВызватьHTTPМетод("GET", ЗапросСекрета);
	
	Если (Ответ.КодСостояния < 200) ИЛИ (Ответ.КодСостояния >= 300) Тогда
		ВызватьИсключение СтрШаблон("Ошибка запроса секрета в Vault : код состояния %1; ; Vault путь: %3
									|%2'"
									,Строка(Ответ.КодСостояния)
									,Ответ.ПолучитьТелоКакСтроку()
									,Путь);
	КонецЕсли;
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(Ответ.ПолучитьТелоКакСтроку());
	Ответ_Структура = ПрочитатьJSON(Чтение);
	Чтение.Закрыть();
	Возврат Ответ_Структура.data.data[ИмяСекрета];
КонецФункции

Процедура Волт_ОбновитьКлюч() Экспорт
	Попытка
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	т.Ссылка КАК Ссылка,
		|	т.ИмяРоли КАК ИмяРоли,
		|	т.ВремяЖизниТокена КАК ВремяЖизниТокена
		|ИЗ
		|	Справочник.Волт_Настройка КАК т
		|ГДЕ
		|	т.Ссылка = ЗНАЧЕНИЕ(Справочник.Волт_Настройка.Волт)";
		РезультатЗапроса = Запрос.Выполнить();
		Если РезультатЗапроса.Пустой() Тогда
			ВызватьИсключение "Не удалось найти настройку Vault";
		КонецЕсли;
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Если НЕ ЗначениеЗаполнено(Выборка.ИмяРоли) Тогда
			ВызватьИсключение "Роль Vault не заполнена";
		КонецЕсли;
		
		ВремяЖизниТокена = ?(ЗначениеЗаполнено(Выборка.ВремяЖизниТокена), Число(Выборка.ВремяЖизниТокена), 30);
		ТокенИОткрытыйКлюч = ТокенДоступаИНаборКлючей(Выборка.ИмяРоли, ВремяЖизниТокена);
		
		НастройкаОбъект = Выборка.Ссылка.ПолучитьОбъект();
		НастройкаОбъект.ТокенДоступа = ТокенИОткрытыйКлюч.Токен;
		НастройкаОбъект.ОткрытыйКлюч = ТокенИОткрытыйКлюч.НаборКлючей;
		Если НЕ ЗначениеЗаполнено(НастройкаОбъект.ВремяЖизниТокена) Тогда
			НастройкаОбъект.ВремяЖизниТокена = ВремяЖизниТокена;
		КонецЕсли;
		НастройкаОбъект.Записать();
	Исключение
		ВызватьИсключение ИнформацияОбОшибке();
	КонецПопытки;
КонецПроцедуры
#Область Волт_ОбновитьКлюч
Функция ТокенДоступаИНаборКлючей(ИмяПриложения, ВремяЖизниТокена) Экспорт
	ИдентификаторСопоставления = Строка(Новый УникальныйИдентификатор());
	ПараКлючейХМЛ = СлучайнаяПараКлючейХМЛ();
	Результат = Новый Структура;
	Результат.Вставить("Токен", ПолучитьТокен(ПараКлючейХМЛ, ИдентификаторСопоставления, ИмяПриложения, ВремяЖизниТокена));
	Результат.Вставить("НаборКлючей", НаборКлючей(ПараКлючейХМЛ, ИдентификаторСопоставления));
	Возврат Результат;
КонецФункции
Функция СлучайнаяПараКлючейХМЛ()
	ОболочкаОбъект = Новый COMОбъект("WScript.Shell");
	ТекстКомандыПоверШелл = "(New-Object System.Security.Cryptography.RSACryptoServiceProvider(2048)).ToXmlString($true)";
	ВыполнениеОбъект = ОболочкаОбъект.Exec(СтрШаблон("powershell -command ""%1""", ТекстКомандыПоверШелл));
	Результат = ВыполнениеОбъект.stdout.readall();
	ОболочкаОбъект = Неопределено;
	ВыполнениеОбъект = Неопределено;
	Возврат Результат;
КонецФункции
Функция НаборКлючей(ПараКлючейХМЛ, ИдентификаторСопоставления)
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ПараКлючейХМЛ);
	ПубличныйКлюч = "";
	Экспонента = "";
	Пока Чтение.Прочитать() Цикл
		Если Чтение.Имя = "Modulus" И Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Чтение.Прочитать();
			ПубличныйКлюч = Чтение.Значение;
		КонецЕсли;
		Если Чтение.Имя = "Exponent" И Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Чтение.Прочитать();
			Экспонента = Чтение.Значение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если НЕ ЗначениеЗаполнено(ПубличныйКлюч)
		ИЛИ НЕ ЗначениеЗаполнено(Экспонента) Тогда
		ВызватьИсключение "Cannot get public key or exponent from XML key pair";
	КонецЕсли;
	
	ПубличныйКлючBase64Url = Base64Url(ПолучитьДвоичныеДанныеИзBase64Строки(ПубличныйКлюч));
	
	Структура_НаборКлючей = Новый Структура;
	Структура_НаборКлючей.Вставить("kty", "RSA");
	Структура_НаборКлючей.Вставить("kid", ИдентификаторСопоставления);
	Структура_НаборКлючей.Вставить("e", Экспонента);
	Структура_НаборКлючей.Вставить("n", ПубличныйКлючBase64Url);
	Структура_НаборКлючей.Вставить("use", "sig");
	Структура_НаборКлючей.Вставить("alg", "RS256");
	
	Структура_Шапка = Новый Структура;
	Массив_Элемент = Новый Массив;
	Массив_Элемент.Добавить(Структура_НаборКлючей);
	Структура_Шапка.Вставить("keys", Массив_Элемент);
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	ЗаписатьJSON(Запись, Структура_Шапка);
	Возврат Запись.Закрыть();
КонецФункции
Функция ПолучитьТокен(ПараКлючейХМЛ, ИдентификаторСопоставления, ИмяПриложения, ВремяЖизниТокена)
	
	АлгоритмХеширования = "SHA256";
    ТекстТокенаБезПодписи = ТекстТокенаБезПодписи(ИдентификаторСопоставления, ИмяПриложения, ВремяЖизниТокена);
    
    Хеширование = Новый ХешированиеДанных(ХешФункция[АлгоритмХеширования]);
    Хеширование.Добавить(ТекстТокенаБезПодписи);
    ХешСуммаТокена = Хеширование.ХешСумма;
    
    КрПровайдер = Новый COMОбъект("System.Security.Cryptography.RSACryptoServiceProvider");
	КрПровайдер.FromXMLString(ПараКлючейХМЛ);
		
    SafeArrayBinХешСуммаТокена = SafeИзДвоичных(ХешСуммаТокена);
    SafeArrayBinПодпись = КрПровайдер.SignHash(SafeArrayBinХешСуммаТокена, АлгоритмХеширования);
    ПодписьДвоичныеДанные = ДвоичныеИзSafe(SafeArrayBinПодпись); 
    ПодписьБ64 = Base64Url(ПодписьДвоичныеДанные);
    
    ТекстТокенаБезПодписи = СтрЗаменить(ТекстТокенаБезПодписи,"{","");
    ТекстТокенаБезПодписи = СтрЗаменить(ТекстТокенаБезПодписи,"}","");
	Возврат СтрШаблон("%1.%2", ТекстТокенаБезПодписи, ПодписьБ64);
КонецФункции
Функция ПолучитьРазделДжейсон(Структура)
    Запись = Новый ЗаписьJson;
    Запись.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
    ЗаписатьJSON(Запись, Структура);
    Возврат Запись.Закрыть();
КонецФункции
Функция ТекстТокенаБезПодписи(ИдентификаторСопоставления, ИмяПриложения, ВремяЖизниТокена)
    Структура = Новый Структура;
	
    Структура.Вставить("alg", "RS256"); 
    Структура.Вставить("typ", "JWT");
    ЗаголовокТокена = ПолучитьРазделДжейсон(Структура);
    ЗаголовокТокенаБ64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(ЗаголовокТокена));
	
    Структура.Очистить();
	
	Структура.Вставить("sub", ИмяПриложения); 
	Структура.Вставить(ИмяПриложения, ИмяПриложения); 
	Структура.Вставить("kid", ИдентификаторСопоставления);
	
	ВремяВыпускаТокена = УниверсальноеВремя(ТекущаяДата()) - Дата(1970,1,1);
	ТокенГоденДо = ВремяВыпускаТокена + ВремяЖизниТокена * 60;
	Структура.Вставить("iat", ВремяВыпускаТокена);
    Структура.Вставить("exp", ТокенГоденДо);
    
    ЗаявкаТокена = ПолучитьРазделДжейсон(Структура);
    ЗаявкаТокенаБ64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(ЗаявкаТокена));
    
	Возврат СтрШаблон("%1.%2", ЗаголовокТокенаБ64, ЗаявкаТокенаБ64);
КонецФункции
Функция Base64Url(ДвоичныеДанные)
    
    Бейс64Строка = Base64Строка(ДвоичныеДанные);
    Бейс64Строка = стрЗаменить(Бейс64Строка, "+", "-");
    Бейс64Строка = стрЗаменить(Бейс64Строка, "/", "_");
    Бейс64Строка = стрЗаменить(Бейс64Строка, Символы.ВК, "");
    Бейс64Строка = стрЗаменить(Бейс64Строка, Символы.ПС, "");
    
    Если Прав(Бейс64Строка, 2) = "==" Тогда
        Бейс64Строка = Лев(Бейс64Строка,СтрДлина(Бейс64Строка)-2);
    ИначеЕсли Прав(Бейс64Строка, 1) = "=" Тогда
        Бейс64Строка = Лев(Бейс64Строка,СтрДлина(Бейс64Строка)-1);
    КонецЕсли;
    
    Возврат Бейс64Строка;
КонецФункции
Функция SafeИзДвоичных(ДвоичныеДанные)
    Буфер = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
    Байтов = Буфер.Размер;
    COMSafeArray = Новый COMSafeArray("VT_UI1", Байтов);//однобайтовый без знака
    Для сч = 0 по Байтов-1 Цикл
        COMSafeArray.SetValue(сч, Буфер.Получить(сч));
    КонецЦикла;
    Возврат COMSafeArray;
КонецФункции
Функция ДвоичныеИзSafe(SafeArrayBin) 
    Буфер = Новый БуферДвоичныхДанных(SafeArrayBin.GetLength());
    Для сч = 0 по SafeArrayBin.GetUpperBound() Цикл
        Буфер.Установить(сч, SafeArrayBin.GetValue(сч));
    КонецЦикла;
    Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
КонецФункции
#КонецОбласти